---
globs: *.j
description: Zinc 语法与约定（参考 edit/Item/ItemTransport.j），用于 .j 文件
---

## Zinc 语法与代码风格

参考实现见：[edit/Item/ItemTransport.j](mdc:edit/Item/ItemTransport.j) 和 [MallItem.j](mdc:Jass/server/MallItem.j)

- **库结构与区域**
  - 使用 `//! zinc` 与 `//! endzinc` 包裹 Zinc 代码块。
  - 采用 `library X requires Y { ... }` 结构组织模块；在库内定义 `public`/`private` 函数与常量。
  - 初始化逻辑优先放在 `function onInit()` 中完成（注册触发器、定时器、事件等）。

- **常量定义**
  - 使用 `#define` 宏定义常量，放在文件开头，省内存且效率高。
  - 格式：`#define CONSTANT_NAME    value`
  - 示例：`#define MALLITEM_MAX_PLAYERS    12`

- **数组与静态成员**
  - 数组定义使用 `[]` 语法，不是 `array`：`private static string names[];`
  - 静态成员必须初始化：
    - 数字类型：`private static integer count = 0;`
    - 句柄类型：`private static timer t = null;`
    - 字符串：`private static string name = "";`
    - 布尔：`private static boolean ready = false;`

- **结构体方法**
  - 静态方法返回类型：`static method MethodName(params) ->returnType { ... }`
  - 实例方法返回类型：`method MethodName(params) ->returnType { ... }`
  - 无返回类型时省略 `->type` 部分

- **函数与变量**
  - 函数命名使用动词短语；变量使用名词短语，清晰表达含义。
  - 统一在函数体开头声明所有局部变量，再进行赋值与使用（见要点 2）。
  - 避免深层嵌套，优先使用早返回与卫语句。

- **玩家 ID 相关函数**
  - `GetPlayerId(player)` 返回 0 到 玩家数-1（0-based）
  - `GetConvertedPlayerId(player)` 返回 1 到 玩家数（1-based）
  - `Player(integer)` 参数从 0 开始（0-based）
  - `ConvertedPlayer(integer)` 参数从 1 开始（1-based）
  - 错误：`ConvertedPlayer(0)` 会报错
  - 正确：`ConvertedPlayer(1)` 表示第一个玩家

- **事件/触发器/定时器**
  - 触发器创建与注册：`trigger tr = CreateTrigger(); TriggerAddCondition(tr, Condition(function () { ... }));`
  - 定时器：`TimerStart(t, timeout, periodic, function () { ... });`
  - 资源释放：在回调尾部暂停/销毁定时器与触发器，并清理哈希表存储。

- **回调/触发规则**
  - 回调注册：使用 `Condition(code cb)` 包装后用 `TriggerAddCondition(tr, Condition(cb))`
  - 回调触发：使用 `TriggerEvaluate(tr)`，不要使用 `TriggerExecute(tr)`
  - 即时执行：若状态已满足（如 ready=true），注册后立即 `TriggerEvaluate(tr)`

- **字符串与提示**
  - HUD 提示/日志统一用 `DisplayTextToPlayer` 与 `BJDebugMsg`；前缀格式统一（例如：`|cFFFF66CC【消息】|r`）。

### 字面量与数据类型

- **四位字符科技 ID**：在 Zinc 中，`'R015'` 等四位字符是整数字面量，不是字符串
  - 正确：`integer techId = 'R015';`、`SetPlayerTechResearched(p, 'R015', 1);`
  - 错误：`string techId = 'R015';`（这会导致类型错误）

### 表达式与条件选择（不支持三目）

- Zinc 不支持三目运算符 `cond ? a : b`，也不支持直接用布尔与数值相乘来充当条件选择器。
- 请使用项目内提供的 I3/R3/S3 条件选择函数：
  - `I3(cond, a, b)`：根据 `cond` 返回整数 `a` 或 `b`
  - `R3(cond, a, b)`：返回实数 `a` 或 `b`
  - `S3(cond, a, b)`：返回字符串 `a` 或 `b`

错误写法（示例）：

```jass
CreateUnit(p, 'nmgv', 10175.0 + ModuloInteger(pid - 1, 3) * 132.0, (- 691.0 + (pid > 3) * 630.4), 270.000);
```

正确写法（示例）：

```jass
UDepot[pid] = CreateUnit(p, 'nmgv', 10175.0 + ModuloInteger(pid - 1, 3) * 132.0, (- 691.0 + R3(pid > 3, 1, 0) * 630.4), 270.000);
```

### 强制约定

1) 不支持闭包传捕外层局部变量（无闭包）
- 不允许在匿名回调 `function () { ... }` 内直接访问其外层函数的局部变量。
- 需要在回调中使用的数据，必须通过哈希表（如 `spellTable`）进行显式存取：在外层保存，回调中通过 `GetExpiredTimer()/GetTriggerUnit()` 的句柄 id 读取。

2) 局部变量必须在函数体开头声明
- 在任意可执行语句之前，先声明本函数需要的全部局部变量（类型齐备：`integer`, `real`, `boolean`, 以及各类 `handle`）。
- 禁止在中途首次声明后再使用；如需新增，回到函数顶部统一声明。

3) 所有 handler 类局部变量在函数尾部置空
- 包含但不限于：`unit`, `item`, `timer`, `trigger`, `effect`, `group`, `location`, `force`, `region`, `dialog`, `boolexpr` 等。
- 在回调/函数结束前：释放可释放对象（如 `PauseTimer/DestroyTimer`、`DestroyTrigger`、`DestroyGroup` 等），随后将对应局部变量 `set null`，防止句柄泄漏。

### 推荐模板（示例）

```jass
// 常量定义在文件开头
#define MAX_PLAYERS    12
#define MAX_ITEMS      256

//! zinc
library ExampleZinc requires LHBase {

    public struct ExampleStruct {
        // 静态成员初始化
        private static boolean initialized = false;
        private static integer count = 0;
        private static hashtable table = null;
        private static string data[];

        // 统一函数入口：初始化触发/定时器等
        static method onInit() {
            trigger tr; // 声明在前

            ExampleStruct.table = InitHashtable();
            tr = CreateTrigger();
            TriggerAddCondition(tr, Condition(function () {
                // 在匿名回调中禁止直接访问外层局部变量
                // 需要的数据请事先用哈希表保存，在此处通过 key 读取
            }));
            tr = null; // handler 置空（如果触发器后续不再使用，注意销毁处理）
        }

        // 带定时器回调的数据传递范式（无闭包，用哈希表）
        static method StartSomething(unit u) ->boolean {
            timer t; integer id; integer someInt; item it; // 先声明

            // ... 业务逻辑，准备需要传入回调的数据
            t = CreateTimer();
            id = GetHandleId(t);
            SaveUnitHandle(spellTable, id, 1, u);
            SaveInteger(spellTable, id, 2, someInt);
            SaveItemHandle(spellTable, id, 3, it);

            TimerStart(t, 0.00, false, function () {
                timer tt; integer hid; unit ru; integer val; item rit; // 回调内部同样先声明

                tt = GetExpiredTimer();
                hid = GetHandleId(tt);
                ru  = LoadUnitHandle(spellTable, hid, 1);
                val = LoadInteger(spellTable,  hid, 2);
                rit = LoadItemHandle(spellTable, hid, 3);

                // ... 使用 ru/val/rit 进行逻辑处理

                PauseTimer(tt);
                FlushChildHashtable(spellTable, hid);
                DestroyTimer(tt);

                // handler 置空，防泄漏
                rit = null; ru = null; tt = null;
            });

            // 外层 handler 置空
            it = null; t = null;
            return true;
        }
    }
}
//! endzinc
```

### 参考实现要点（摘自 ItemTransport）
- 通过 `GetHandleId(timer)` 作为 key 将 `pos/item/unit` 存入 `spellTable`；在回调中通过 `GetExpiredTimer()` 读取。
- 当判定物品仍在原位置后，进行跨单位背包转移，并使用 `DisplayTextToPlayer` 与 `BJDebugMsg` 输出。
- 回调结束：`PauseTimer/DestroyTimer`，`FlushChildHashtable`，并对 `unit/item/timer` 置 `null`。

以上规则为初始版本，如与现有代码风格冲突，以本规则为准并逐步迁移。

