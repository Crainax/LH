---
globs: *.j
description: Zinc 语法与约定（参考 edit/Item/ItemTransport.j），用于 .j 文件
---

## Zinc 语法与代码风格（初始版本）

参考实现见：[edit/Item/ItemTransport.j](mdc:edit/Item/ItemTransport.j)

- **库结构与区域**
  - 使用 `//! zinc` 与 `//! endzinc` 包裹 Zinc 代码块。
  - 采用 `library X requires Y { ... }` 结构组织模块；在库内定义 `public`/`private` 函数与常量。
  - 初始化逻辑优先放在 `function onInit()` 中完成（注册触发器、定时器、事件等）。

- **函数与变量**
  - 函数命名使用动词短语；变量使用名词短语，清晰表达含义。
  - 统一在函数体开头声明所有局部变量，再进行赋值与使用（见要点 2）。
  - 避免深层嵌套，优先使用早返回与卫语句。

- **事件/触发器/定时器**
  - 触发器创建与注册：`trigger tr = CreateTrigger(); TriggerAddCondition(tr, Condition(function () { ... }));`
  - 定时器：`TimerStart(t, timeout, periodic, function () { ... });`
  - 资源释放：在回调尾部暂停/销毁定时器与触发器，并清理哈希表存储。

- **字符串与提示**
  - HUD 提示/日志统一用 `DisplayTextToPlayer` 与 `BJDebugMsg`；前缀格式统一（例如：`|cFFFF66CC【消息】|r`）。

### 表达式与条件选择（不支持三目）

- Zinc 不支持三目运算符 `cond ? a : b`，也不支持直接用布尔与数值相乘来充当条件选择器。
- 请使用项目内提供的 I3/R3/S3 条件选择函数：
  - `I3(cond, a, b)`：根据 `cond` 返回整数 `a` 或 `b`
  - `R3(cond, a, b)`：返回实数 `a` 或 `b`
  - `S3(cond, a, b)`：返回字符串 `a` 或 `b`

错误写法（示例）：

```jass
CreateUnit(p, 'nmgv', 10175.0 + ModuloInteger(pid - 1, 3) * 132.0, (- 691.0 + (pid > 3) * 630.4), 270.000);
```

正确写法（示例）：

```jass
UDepot[pid] = CreateUnit(p, 'nmgv', 10175.0 + ModuloInteger(pid - 1, 3) * 132.0, (- 691.0 + R3(pid > 3, 1, 0) * 630.4), 270.000);
```

### 强制约定

1) 不支持闭包传捕外层局部变量（无闭包）
- 不允许在匿名回调 `function () { ... }` 内直接访问其外层函数的局部变量。
- 需要在回调中使用的数据，必须通过哈希表（如 `spellTable`）进行显式存取：在外层保存，回调中通过 `GetExpiredTimer()/GetTriggerUnit()` 的句柄 id 读取。

2) 局部变量必须在函数体开头声明
- 在任意可执行语句之前，先声明本函数需要的全部局部变量（类型齐备：`integer`, `real`, `boolean`, 以及各类 `handle`）。
- 禁止在中途首次声明后再使用；如需新增，回到函数顶部统一声明。

3) 所有 handler 类局部变量在函数尾部置空
- 包含但不限于：`unit`, `item`, `timer`, `trigger`, `effect`, `group`, `location`, `force`, `region`, `dialog`, `boolexpr` 等。
- 在回调/函数结束前：释放可释放对象（如 `PauseTimer/DestroyTimer`、`DestroyTrigger`、`DestroyGroup` 等），随后将对应局部变量 `set null`，防止句柄泄漏。

### 推荐模板（示例）

```jass
//! zinc
library ExampleZinc requires LHBase {

    // 统一函数入口：初始化触发/定时器等
    function onInit() {
        trigger tr; // 声明在前
        tr = CreateTrigger();
        TriggerAddCondition(tr, Condition(function () {
            // 在匿名回调中禁止直接访问外层局部变量
            // 需要的数据请事先用哈希表保存，在此处通过 key 读取
        }));
        tr = null; // handler 置空（如果触发器后续不再使用，注意销毁处理）
    }

    // 带定时器回调的数据传递范式（无闭包，用哈希表）
    function StartSomething(unit u) {
        timer t; integer id; integer someInt; item it; // 先声明

        // ... 业务逻辑，准备需要传入回调的数据
        t = CreateTimer();
        id = GetHandleId(t);
        SaveUnitHandle(spellTable, id, 1, u);
        SaveInteger(spellTable, id, 2, someInt);
        SaveItemHandle(spellTable, id, 3, it);

        TimerStart(t, 0.00, false, function () {
            timer tt; integer hid; unit ru; integer val; item rit; // 回调内部同样先声明

            tt = GetExpiredTimer();
            hid = GetHandleId(tt);
            ru  = LoadUnitHandle(spellTable, hid, 1);
            val = LoadInteger(spellTable,  hid, 2);
            rit = LoadItemHandle(spellTable, hid, 3);

            // ... 使用 ru/val/rit 进行逻辑处理

            PauseTimer(tt);
            FlushChildHashtable(spellTable, hid);
            DestroyTimer(tt);

            // handler 置空，防泄漏
            rit = null; ru = null; tt = null;
        });

        // 外层 handler 置空
        it = null; t = null;
    }
}
//! endzinc
```

### 参考实现要点（摘自 ItemTransport）
- 通过 `GetHandleId(timer)` 作为 key 将 `pos/item/unit` 存入 `spellTable`；在回调中通过 `GetExpiredTimer()` 读取。
- 当判定物品仍在原位置后，进行跨单位背包转移，并使用 `DisplayTextToPlayer` 与 `BJDebugMsg` 输出。
- 回调结束：`PauseTimer/DestroyTimer`，`FlushChildHashtable`，并对 `unit/item/timer` 置 `null`。

以上规则为初始版本，如与现有代码风格冲突，以本规则为准并逐步迁移。

